"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream = void 0;
const executeQuery_1 = require("../routines/executeQuery");
const node_stream_1 = require("node:stream");
const promises_1 = require("node:stream/promises");
const createTransformStream = (clientConfiguration, queryContext, query) => {
    const rowTransformers = [];
    for (const interceptor of clientConfiguration.interceptors) {
        if (interceptor.transformRow) {
            rowTransformers.push(interceptor.transformRow);
        }
    }
    return new node_stream_1.Transform({
        objectMode: true,
        async transform(datum, enc, callback) {
            if (!datum.row) {
                callback(new Error('"row" not available'));
                return;
            }
            if (!datum.fields) {
                callback(new Error('"fields" not available'));
                return;
            }
            let finalRow = datum.row;
            // apply row transformers. Note this is done sequentially, as one transformer's result will be passed to the next.
            for (const rowTransformer of rowTransformers) {
                finalRow = await rowTransformer(queryContext, query, finalRow, datum.fields);
            }
            // eslint-disable-next-line @babel/no-invalid-this
            this.push({
                data: finalRow,
                fields: datum.fields,
            });
            callback();
        },
    });
};
const createExecutionRoutine = (clientConfiguration, onStream) => {
    return async (connection, sql, values, executionContext, actualQuery) => {
        const queryStream = connection.stream(sql, values);
        const transformStream = createTransformStream(clientConfiguration, executionContext, actualQuery);
        onStream(transformStream);
        await (0, promises_1.pipeline)(queryStream, transformStream);
        return {
            notices: [],
            type: 'StreamResult',
        };
    };
};
const stream = async (connectionLogger, connection, clientConfiguration, slonikSql, onStream, uid) => {
    const result = await (0, executeQuery_1.executeQuery)(connectionLogger, connection, clientConfiguration, slonikSql, uid, createExecutionRoutine(clientConfiguration, onStream), true);
    if (result.type === 'QueryResult') {
        throw new Error('Query result cannot be returned in a streaming context.');
    }
    return result;
};
exports.stream = stream;
//# sourceMappingURL=stream.js.map