"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnection = void 0;
const bindPoolConnection_1 = require("../binders/bindPoolConnection");
const errors_1 = require("../errors");
const establishConnection_1 = require("../routines/establishConnection");
const state_1 = require("../state");
const defer_1 = require("../utilities/defer");
const destroyBoundConnection = (boundConnection) => {
    const boundConnectionMethods = [
        'any',
        'anyFirst',
        'exists',
        'many',
        'manyFirst',
        'maybeOne',
        'maybeOneFirst',
        'one',
        'oneFirst',
        'query',
        'stream',
        'transaction',
    ];
    for (const boundConnectionMethod of boundConnectionMethods) {
        boundConnection[boundConnectionMethod] = async () => {
            throw new Error('Cannot use released connection');
        };
    }
};
const raceError = async (connection, routine) => {
    const connectionErrorPromise = (0, defer_1.defer)();
    const onError = (error) => {
        connectionErrorPromise.reject(error);
    };
    connection.on('error', onError);
    try {
        return await Promise.race([connectionErrorPromise.promise, routine()]);
    }
    finally {
        connection.removeListener('error', onError);
    }
};
const createConnection = async (parentLog, pool, clientConfiguration, connectionType, connectionHandler, poolHandler, query = null) => {
    const { state } = pool.state();
    const poolId = pool.id();
    if (state === 'ENDING') {
        throw new errors_1.UnexpectedStateError('Connection pool is being shut down. Cannot create a new connection.');
    }
    if (state === 'ENDED') {
        throw new errors_1.UnexpectedStateError('Connection pool has been shut down. Cannot create a new connection.');
    }
    for (const interceptor of clientConfiguration.interceptors) {
        if (interceptor.beforePoolConnection) {
            const maybeNewPool = await interceptor.beforePoolConnection({
                log: parentLog,
                poolId,
                query,
            });
            if (maybeNewPool) {
                return await poolHandler(maybeNewPool);
            }
        }
    }
    const connection = await (0, establishConnection_1.establishConnection)(parentLog, pool, clientConfiguration.connectionRetryLimit);
    return raceError(connection, async () => {
        const { connectionId } = (0, state_1.getPoolClientState)(connection);
        const connectionLog = parentLog.child({
            connectionId,
        });
        const connectionContext = {
            connectionId,
            connectionType,
            log: connectionLog,
            poolId,
        };
        const boundConnection = (0, bindPoolConnection_1.bindPoolConnection)(connectionLog, connection, clientConfiguration);
        try {
            for (const interceptor of clientConfiguration.interceptors) {
                if (interceptor.afterPoolConnection) {
                    await interceptor.afterPoolConnection(connectionContext, boundConnection);
                }
            }
        }
        catch (error) {
            await connection.destroy();
            throw error;
        }
        let result;
        try {
            result = await connectionHandler(connectionLog, connection, boundConnection, clientConfiguration);
        }
        catch (error) {
            await connection.destroy();
            throw error;
        }
        try {
            for (const interceptor of clientConfiguration.interceptors) {
                if (interceptor.beforePoolConnectionRelease) {
                    await interceptor.beforePoolConnectionRelease(connectionContext, boundConnection);
                }
            }
        }
        catch (error) {
            await connection.destroy();
            throw error;
        }
        destroyBoundConnection(boundConnection);
        await connection.release();
        return result;
    });
};
exports.createConnection = createConnection;
//# sourceMappingURL=createConnection.js.map