"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDriverFactory = void 0;
const Logger_1 = require("../Logger");
const createUid_1 = require("../utilities/createUid");
const node_events_1 = __importDefault(require("node:events"));
const promises_1 = require("node:timers/promises");
const serialize_error_1 = require("serialize-error");
const createDriverFactory = (setup) => {
    return async ({ driverConfiguration }) => {
        const driverEventEmitter = new node_events_1.default();
        const { createPoolClient } = await setup({
            driverConfiguration,
            driverEventEmitter,
        });
        return {
            createClient: async () => {
                const clientEventEmitter = new node_events_1.default();
                // eslint-disable-next-line prefer-const
                let destroy;
                const onError = (error) => {
                    if (destroy) {
                        // eslint-disable-next-line promise/prefer-await-to-then
                        void destroy().catch(() => {
                            // Do nothing. The error has been emitted already.
                            // See "handles unexpected backend termination" test.
                        });
                    }
                    Logger_1.Logger.warn({
                        error: (0, serialize_error_1.serializeError)(error),
                        namespace: 'driverClient',
                    }, 'unhandled driver client error');
                };
                clientEventEmitter.on('error', onError);
                const { query, stream, connect, end } = await createPoolClient({
                    clientEventEmitter,
                });
                let isAcquired = false;
                let isDestroyed = false;
                let idleTimeout = null;
                let activeQueryPromise = null;
                let destroyPromise = null;
                let releasePromise = null;
                const id = (0, createUid_1.createUid)();
                const clearIdleTimeout = () => {
                    if (idleTimeout) {
                        clearTimeout(idleTimeout);
                        idleTimeout = null;
                    }
                };
                const state = () => {
                    if (destroyPromise) {
                        return 'PENDING_DESTROY';
                    }
                    if (releasePromise) {
                        return 'PENDING_RELEASE';
                    }
                    if (isDestroyed) {
                        return 'DESTROYED';
                    }
                    if (isAcquired) {
                        return 'ACQUIRED';
                    }
                    return 'IDLE';
                };
                const internalDestroy = async () => {
                    const currentState = state();
                    if (currentState === 'PENDING_DESTROY') {
                        throw new Error('Client is pending destroy.');
                    }
                    if (currentState === 'DESTROYED') {
                        throw new Error('Client is destroyed.');
                    }
                    clearIdleTimeout();
                    if (activeQueryPromise) {
                        await Promise.race([
                            (0, promises_1.setTimeout)(driverConfiguration.gracefulTerminationTimeout),
                            activeQueryPromise,
                        ]);
                    }
                    isDestroyed = true;
                    clientEventEmitter.emit('destroy');
                    await end();
                    clientEventEmitter.off('error', onError);
                };
                destroy = async () => {
                    if (destroyPromise) {
                        return destroyPromise;
                    }
                    destroyPromise = internalDestroy();
                    return destroyPromise;
                };
                const internalRelease = async () => {
                    const currentState = state();
                    if (currentState === 'PENDING_DESTROY') {
                        throw new Error('Client is pending destroy.');
                    }
                    if (currentState === 'DESTROYED') {
                        throw new Error('Client is destroyed.');
                    }
                    if (currentState !== 'ACQUIRED') {
                        throw new Error('Client is not acquired.');
                    }
                    if (activeQueryPromise) {
                        throw new Error('Client has an active query.');
                    }
                    await query('DISCARD ALL');
                    if (driverConfiguration.idleTimeout !== 'DISABLE_TIMEOUT') {
                        clearIdleTimeout();
                        idleTimeout = setTimeout(() => {
                            void destroy();
                            idleTimeout = null;
                        }, driverConfiguration.idleTimeout).unref();
                    }
                    // eslint-disable-next-line require-atomic-updates
                    isAcquired = false;
                    releasePromise = null;
                    clientEventEmitter.emit('release');
                };
                const release = () => {
                    if (destroyPromise) {
                        return destroyPromise;
                    }
                    if (releasePromise) {
                        return releasePromise;
                    }
                    releasePromise = internalRelease();
                    return releasePromise;
                };
                const client = {
                    acquire: () => {
                        const currentState = state();
                        if (currentState === 'PENDING_DESTROY') {
                            throw new Error('Client is pending destroy.');
                        }
                        if (currentState === 'PENDING_RELEASE') {
                            throw new Error('Client is pending release.');
                        }
                        if (currentState === 'DESTROYED') {
                            throw new Error('Client is destroyed.');
                        }
                        if (currentState === 'ACQUIRED') {
                            throw new Error('Client is already acquired.');
                        }
                        clearIdleTimeout();
                        isAcquired = true;
                        clientEventEmitter.emit('acquire');
                    },
                    destroy,
                    id: () => id,
                    off: (event, listener) => {
                        return clientEventEmitter.off(event, listener);
                    },
                    on: (event, listener) => {
                        return clientEventEmitter.on(event, listener);
                    },
                    query: async (sql, values) => {
                        const currentState = state();
                        if (currentState === 'PENDING_DESTROY') {
                            throw new Error('Client is pending destroy.');
                        }
                        if (currentState === 'PENDING_RELEASE') {
                            throw new Error('Client is pending release.');
                        }
                        if (currentState === 'DESTROYED') {
                            throw new Error('Client is destroyed.');
                        }
                        if (currentState !== 'ACQUIRED') {
                            throw new Error('Client is not acquired.');
                        }
                        try {
                            activeQueryPromise = query(sql, values);
                            const result = await activeQueryPromise;
                            if (!activeQueryPromise) {
                                throw new Error('Expected `activeQueryPromise` to be set.');
                            }
                            return result;
                        }
                        finally {
                            // eslint-disable-next-line require-atomic-updates
                            activeQueryPromise = null;
                        }
                    },
                    release,
                    removeListener: (event, listener) => {
                        return clientEventEmitter.removeListener(event, listener);
                    },
                    state,
                    stream: (sql, values) => {
                        const currentState = state();
                        if (currentState === 'PENDING_DESTROY') {
                            throw new Error('Client is pending destroy.');
                        }
                        if (currentState === 'PENDING_RELEASE') {
                            throw new Error('Client is pending release.');
                        }
                        if (currentState === 'DESTROYED') {
                            throw new Error('Client is destroyed.');
                        }
                        if (currentState !== 'ACQUIRED') {
                            throw new Error('Client is not acquired.');
                        }
                        // TODO determine if streaming and do not allow to release the client until the stream is finished
                        return stream(sql, values);
                    },
                };
                await connect();
                return client;
            },
        };
    };
};
exports.createDriverFactory = createDriverFactory;
//# sourceMappingURL=createDriverFactory.js.map