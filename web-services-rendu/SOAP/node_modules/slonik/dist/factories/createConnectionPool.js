"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnectionPool = void 0;
const Logger_1 = require("../Logger");
const createUid_1 = require("../utilities/createUid");
const defer_1 = require("../utilities/defer");
const promises_1 = require("node:timers/promises");
const serialize_error_1 = require("serialize-error");
const logger = Logger_1.Logger.child({
    namespace: 'createConnectionPool',
});
const createConnectionPool = ({ driver, poolSize = 1, }) => {
    // See test "waits for all connections to be established before attempting to terminate the pool"
    // for explanation of why `pendingConnections` is needed.
    const pendingConnections = [];
    const connections = [];
    const waitingClients = [];
    const id = (0, createUid_1.createUid)();
    let isEnding = false;
    let isEnded = false;
    let poolEndPromise = null;
    const endPool = async () => {
        try {
            await Promise.all(pendingConnections);
        }
        catch (error) {
            logger.error({
                error: (0, serialize_error_1.serializeError)(error),
            }, 'error in pool termination sequence while waiting for pending connections to be established');
        }
        // This is needed to ensure that all pending connections were assigned a waiting client.
        // e.g. "waits for all connections to be established before attempting to terminate the pool" test
        await (0, promises_1.setTimeout)(0);
        await Promise.all(connections.map((connection) => connection.destroy()));
    };
    return {
        acquire: async () => {
            if (isEnding) {
                throw new Error('Connection pool is being terminated.');
            }
            if (isEnded) {
                throw new Error('Connection pool has ended.');
            }
            const idleConnection = connections.find((connection) => connection.state() === 'IDLE');
            if (idleConnection) {
                idleConnection.acquire();
                return idleConnection;
            }
            if (pendingConnections.length + connections.length < poolSize) {
                const pendingConnection = driver.createClient();
                pendingConnections.push(pendingConnection);
                const connection = await pendingConnection;
                const onRelease = () => {
                    const waitingClient = waitingClients.shift();
                    if (!waitingClient) {
                        return;
                    }
                    if (connection.state() !== 'IDLE') {
                        throw new Error('Connection is not idle.');
                    }
                    connection.acquire();
                    waitingClient.resolve(connection);
                };
                connection.on('release', onRelease);
                const onDestroy = () => {
                    connection.removeListener('release', onRelease);
                    connection.removeListener('destroy', onDestroy);
                    connections.splice(connections.indexOf(connection), 1);
                };
                connection.on('destroy', onDestroy);
                connection.acquire();
                connections.push(connection);
                pendingConnections.splice(pendingConnections.indexOf(pendingConnection), 1);
                return connection;
            }
            else {
                const waitingClient = (0, defer_1.defer)();
                waitingClients.push(waitingClient);
                return waitingClient.promise;
            }
        },
        end: async () => {
            isEnding = true;
            if (poolEndPromise) {
                return poolEndPromise;
            }
            poolEndPromise = endPool();
            isEnded = true;
            return poolEndPromise;
        },
        id: () => {
            return id;
        },
        state: () => {
            const stateName = isEnded ? 'ENDED' : isEnding ? 'ENDING' : 'ACTIVE';
            const state = {
                acquiredConnections: 0,
                idleConnections: 0,
                pendingDestroyConnections: 0,
                pendingReleaseConnections: 0,
            };
            // TODO add pendingAcquireConnections
            // TODO add destroyedConnections
            for (const connection of connections) {
                if (connection.state() === 'ACQUIRED') {
                    state.acquiredConnections++;
                }
                if (connection.state() === 'IDLE') {
                    state.idleConnections++;
                }
                if (connection.state() === 'PENDING_RELEASE') {
                    state.pendingReleaseConnections++;
                }
                if (connection.state() === 'PENDING_DESTROY') {
                    state.pendingDestroyConnections++;
                }
                if (connection.state() === 'DESTROYED') {
                    state.pendingReleaseConnections++;
                }
            }
            return {
                ...state,
                state: stateName,
                waitingClients: waitingClients.length,
            };
        },
    };
};
exports.createConnectionPool = createConnectionPool;
//# sourceMappingURL=createConnectionPool.js.map