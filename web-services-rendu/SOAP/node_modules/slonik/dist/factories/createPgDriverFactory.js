"use strict";
/* eslint-disable canonical/id-match */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPgDriverFactory = void 0;
const errors_1 = require("../errors");
const parseDsn_1 = require("../utilities/parseDsn");
const createDriverFactory_1 = require("./createDriverFactory");
const node_stream_1 = require("node:stream");
// eslint-disable-next-line no-restricted-imports
const pg_1 = require("pg");
const pg_query_stream_1 = __importDefault(require("pg-query-stream"));
const pg_types_1 = require("pg-types");
const postgres_array_1 = require("postgres-array");
const createTypeOverrides = async (connection, typeParsers) => {
    const typeNames = typeParsers.map((typeParser) => {
        return typeParser.name;
    });
    const postgresTypes = (await connection.query(`
        SELECT
          oid,
          typarray,
          typname
        FROM pg_type
        WHERE typname = ANY($1::text[])
      `, [typeNames])).rows;
    const parsers = {};
    for (const typeParser of typeParsers) {
        const postgresType = postgresTypes.find((maybeTargetPostgresType) => {
            return maybeTargetPostgresType.typname === typeParser.name;
        });
        if (!postgresType) {
            throw new Error('Database type "' + typeParser.name + '" not found.');
        }
        parsers[postgresType.oid] = (value) => {
            return typeParser.parse(value);
        };
        if (postgresType.typarray) {
            parsers[postgresType.typarray] = (arrayValue) => {
                return (0, postgres_array_1.parse)(arrayValue).map((value) => {
                    return typeParser.parse(value);
                });
            };
        }
    }
    return (oid) => {
        if (parsers[oid]) {
            return parsers[oid];
        }
        return (0, pg_types_1.getTypeParser)(oid);
    };
};
const createClientConfiguration = (clientConfiguration) => {
    const connectionOptions = (0, parseDsn_1.parseDsn)(clientConfiguration.connectionUri);
    const poolConfiguration = {
        application_name: connectionOptions.applicationName,
        database: connectionOptions.databaseName,
        host: connectionOptions.host,
        options: connectionOptions.options,
        password: connectionOptions.password,
        port: connectionOptions.port,
        ssl: false,
        user: connectionOptions.username,
    };
    if (clientConfiguration.ssl) {
        poolConfiguration.ssl = clientConfiguration.ssl;
    }
    else if (connectionOptions.sslMode === 'disable') {
        poolConfiguration.ssl = false;
    }
    else if (connectionOptions.sslMode === 'require') {
        poolConfiguration.ssl = true;
    }
    else if (connectionOptions.sslMode === 'no-verify') {
        poolConfiguration.ssl = {
            rejectUnauthorized: false,
        };
    }
    if (clientConfiguration.connectionTimeout !== 'DISABLE_TIMEOUT') {
        if (clientConfiguration.connectionTimeout === 0) {
            poolConfiguration.connectionTimeoutMillis = 1;
        }
        else {
            poolConfiguration.connectionTimeoutMillis =
                clientConfiguration.connectionTimeout;
        }
    }
    if (clientConfiguration.statementTimeout !== 'DISABLE_TIMEOUT') {
        if (clientConfiguration.statementTimeout === 0) {
            poolConfiguration.statement_timeout = 1;
        }
        else {
            poolConfiguration.statement_timeout =
                clientConfiguration.statementTimeout;
        }
    }
    if (clientConfiguration.idleInTransactionSessionTimeout !== 'DISABLE_TIMEOUT') {
        if (clientConfiguration.idleInTransactionSessionTimeout === 0) {
            poolConfiguration.idle_in_transaction_session_timeout = 1;
        }
        else {
            poolConfiguration.idle_in_transaction_session_timeout =
                clientConfiguration.idleInTransactionSessionTimeout;
        }
    }
    return poolConfiguration;
};
const queryTypeOverrides = async (pgClientConfiguration, driverConfiguration) => {
    const client = new pg_1.Client(pgClientConfiguration);
    await client.connect();
    const typeOverrides = await createTypeOverrides(client, driverConfiguration.typeParsers);
    await client.end();
    return typeOverrides;
};
const isErrorWithCode = (error) => {
    return 'code' in error;
};
// query is not available for connection-level errors.
// TODO evaluate if we can remove query from the error object.
// I suspect we should not be even using InputSyntaxError as one of the error types.
// @see https://github.com/gajus/slonik/issues/557
const wrapError = (error, query) => {
    if (error.message.toLowerCase().includes('connection terminated unexpectedly')) {
        return new errors_1.BackendTerminatedUnexpectedlyError(error);
    }
    if (error.message.toLowerCase().includes('connection terminated')) {
        return new errors_1.BackendTerminatedError(error);
    }
    if (!isErrorWithCode(error)) {
        return error;
    }
    if (error.code === '22P02') {
        return new errors_1.InvalidInputError(error.message);
    }
    if (error.code === '25P03') {
        return new errors_1.IdleTransactionTimeoutError(error);
    }
    if (error.code === '57P01') {
        return new errors_1.BackendTerminatedError(error);
    }
    if (error.code === '57014' &&
        // The code alone is not enough to distinguish between a statement timeout and a statement cancellation.
        error.message.includes('canceling statement due to user request')) {
        return new errors_1.StatementCancelledError(error);
    }
    if (error.code === '57014') {
        return new errors_1.StatementTimeoutError(error);
    }
    if (error.code === '23502') {
        return new errors_1.NotNullIntegrityConstraintViolationError(error);
    }
    if (error.code === '23503') {
        return new errors_1.ForeignKeyIntegrityConstraintViolationError(error);
    }
    if (error.code === '23505') {
        return new errors_1.UniqueIntegrityConstraintViolationError(error);
    }
    if (error.code === '23514') {
        return new errors_1.CheckIntegrityConstraintViolationError(error);
    }
    if (error.code === '42601') {
        if (!query) {
            return new errors_1.UnexpectedStateError('Expected query to be provided');
        }
        return new errors_1.InputSyntaxError(error, query);
    }
    return error;
};
const createPgDriverFactory = () => {
    return (0, createDriverFactory_1.createDriverFactory)(async ({ driverConfiguration }) => {
        const clientConfiguration = createClientConfiguration(driverConfiguration);
        // eslint-disable-next-line require-atomic-updates
        clientConfiguration.types = {
            getTypeParser: await queryTypeOverrides(clientConfiguration, driverConfiguration),
        };
        return {
            createPoolClient: async ({ clientEventEmitter }) => {
                const client = new pg_1.Client(clientConfiguration);
                // We will see this triggered when the connection is terminated, e.g.
                // "terminates transactions that are idle beyond idleInTransactionSessionTimeout" test.
                const onError = (error) => {
                    clientEventEmitter.emit('error', wrapError(error, null));
                };
                const onNotice = (notice) => {
                    if (notice.message) {
                        clientEventEmitter.emit('notice', {
                            message: notice.message,
                        });
                    }
                };
                client.on('error', onError);
                client.on('notice', onNotice);
                return {
                    connect: async () => {
                        await client.connect();
                    },
                    end: async () => {
                        await client.end();
                        client.removeListener('error', onError);
                        client.removeListener('notice', onNotice);
                    },
                    query: async (sql, values) => {
                        let result;
                        try {
                            result = await client.query(sql, values);
                        }
                        catch (error) {
                            throw wrapError(error, {
                                sql,
                                values: values,
                            });
                        }
                        return {
                            command: result.command,
                            fields: result.fields.map((field) => {
                                return {
                                    dataTypeId: field.dataTypeID,
                                    name: field.name,
                                };
                            }),
                            rowCount: result.rowCount,
                            rows: result.rows,
                        };
                    },
                    stream: (sql, values) => {
                        const stream = client.query(new pg_query_stream_1.default(sql, values));
                        let fields = [];
                        // `rowDescription` will not fire if the query produces a syntax error.
                        // Also, `rowDescription` won't fire until client starts consuming the stream.
                        // This is why we cannot simply await for `rowDescription` event before starting to pipe the stream.
                        // @ts-expect-error â€“ https://github.com/brianc/node-postgres/issues/3015
                        client.connection.once('rowDescription', (rowDescription) => {
                            fields = rowDescription.fields.map((field) => {
                                return {
                                    dataTypeId: field.dataTypeID,
                                    name: field.name,
                                };
                            });
                        });
                        const transform = new node_stream_1.Transform({
                            objectMode: true,
                            async transform(datum, enc, callback) {
                                if (!fields) {
                                    callback(new Error('Fields not available'));
                                    return;
                                }
                                // eslint-disable-next-line @babel/no-invalid-this
                                this.push({
                                    fields,
                                    row: datum,
                                });
                                callback();
                            },
                        });
                        stream.on('error', (error) => {
                            transform.emit('error', wrapError(error, {
                                sql,
                                values: values,
                            }));
                        });
                        return stream.pipe(transform);
                    },
                };
            },
        };
    });
};
exports.createPgDriverFactory = createPgDriverFactory;
//# sourceMappingURL=createPgDriverFactory.js.map