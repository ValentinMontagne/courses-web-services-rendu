/// <reference types="node" />
/// <reference types="node" />
import { type TypedReadable, type TypeParser } from '../types';
import EventEmitter from 'node:events';
import { type ConnectionOptions as TlsConnectionOptions } from 'node:tls';
import { type StrictEventEmitter } from 'strict-event-emitter-types';
export type DriverConfiguration = {
    readonly connectionTimeout: number | 'DISABLE_TIMEOUT';
    readonly connectionUri: string;
    readonly gracefulTerminationTimeout?: number;
    readonly idleInTransactionSessionTimeout: number | 'DISABLE_TIMEOUT';
    readonly idleTimeout?: number | 'DISABLE_TIMEOUT';
    readonly maximumPoolSize?: number;
    readonly ssl?: TlsConnectionOptions;
    readonly statementTimeout: number | 'DISABLE_TIMEOUT';
    readonly typeParsers: readonly TypeParser[];
};
export type DriverNotice = {
    message: string;
};
export type DriverEventEmitter = StrictEventEmitter<EventEmitter, {
    error: (error: Error) => void;
}>;
export type DriverClientEventEmitter = StrictEventEmitter<EventEmitter, {
    acquire: () => void;
    destroy: () => void;
    error: (error: Error) => void;
    notice: (event: DriverNotice) => void;
    release: () => void;
}>;
export type DriverClientState = 'ACQUIRED' | 'DESTROYED' | 'IDLE' | 'PENDING_DESTROY' | 'PENDING_RELEASE';
export type DriverClient = {
    acquire: () => void;
    destroy: () => Promise<void>;
    id: () => string;
    off: DriverClientEventEmitter['off'];
    on: DriverClientEventEmitter['on'];
    query: (query: string, values?: unknown[]) => Promise<DriverQueryResult>;
    release: () => Promise<void>;
    removeListener: DriverClientEventEmitter['removeListener'];
    state: () => DriverClientState;
    stream: (query: string, values?: unknown[]) => TypedReadable<DriverStreamResult>;
};
export type Driver = {
    createClient: () => Promise<DriverClient>;
};
export type DriverFactory = ({ driverConfiguration, }: {
    driverConfiguration: DriverConfiguration;
}) => Promise<Driver>;
type DriverField = {
    dataTypeId: number;
    name: string;
};
export type DriverCommand = 'COPY' | 'DELETE' | 'INSERT' | 'SELECT' | 'UPDATE';
export type DriverQueryResult = {
    readonly command: DriverCommand;
    readonly fields: DriverField[];
    readonly rowCount: number | null;
    readonly rows: Array<Record<string, unknown>>;
};
export type DriverStreamResult = {
    readonly fields: DriverField[];
    readonly row: Record<string, unknown>;
};
type DriverSetup = ({ driverEventEmitter, driverConfiguration, }: {
    driverConfiguration: DriverConfiguration;
    driverEventEmitter: DriverEventEmitter;
}) => Promise<InternalPoolClientFactory>;
/**
 * @property {Function} connect - Connect to the database. The client must not be used before this method is called.
 * @property {Function} end - Disconnect from the database. The client must not be used after this method is called.
 * @property {Function} query - Execute a SQL query.
 */
type InternalPoolClient = {
    connect: () => Promise<void>;
    end: () => Promise<void>;
    query: (query: string, values?: unknown[]) => Promise<DriverQueryResult>;
    stream: (query: string, values?: unknown[]) => TypedReadable<DriverStreamResult>;
};
type InternalPoolClientFactory = {
    createPoolClient: ({ clientEventEmitter, }: {
        clientEventEmitter: DriverClientEventEmitter;
    }) => Promise<InternalPoolClient>;
};
export declare const createDriverFactory: (setup: DriverSetup) => DriverFactory;
export {};
//# sourceMappingURL=createDriverFactory.d.ts.map